<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="../node_modules/vue/dist/vue.js"></script>
    <script src="../node_modules/three/build/three.js"></script>
    <script src="../node_modules/three/examples/js/controls/OrbitControls.js"></script>
    <script src="../node_modules/d3/dist/d3.js"></script>
    <style>
        #label{
            position: absolute;
            z-index: 2;
            background: white;
            padding: 10px;
            border-radius: 2px;
            visibility: hidden;
        }
        #test {
            position: absolute;
            z-index: 2;
            background: white;
            padding: 10px;
            border-radius: 2px;
            top: 20px;
            left: 20px;
        }
        .data-list{
            padding: 10px;
            cursor: pointer;
            border-bottom: #27363D solid 1px;
        }
        .data-list:hover{
            background: rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
<div id="app">
    <div ref="label" id="label"></div>
<!--    <div id="test">-->
<!--        <div>播放列表：</div>-->
<!--        <div v-for="(data, index) in songs" :key="index">-->
<!--            <div class="data-list" @click="showRegion(data.type)">-->
<!--                <div>{{ data.title }}</div>-->
<!--                <div style="margin-top: 10px">{{ '歌谣分布地：' + data.type }}</div>-->
<!--            </div>-->
<!--        </div>-->
<!--    </div>-->
    <div id="container"></div>
</div>
<script>

    const myapp = new Vue({
        el: "#app",
        data() {
            return {
                scene: '',
                raycaster: '',
                renderer: '',
                camera: '',
                controls: '',
                map: '',
                ambientLight: '',
                mouse: '',
                projection:'',
                lable: '',
                lastPick: '',
                lastSearch: '',
                obj3d: null,
                songs: [
                    {
                        title: '少数民族歌谣01',
                        type: ['福建省', '北京市']
                    },
                    {
                        title: '少数民族歌谣02',
                        type: ['福建省']
                    },
                    {
                        title: '少数民族歌谣03',
                        type: ['浙江省']
                    },
                    {
                        title: '少数民族歌谣04',
                        type: ['新疆维吾尔自治区', '黑龙江省', '广东省']
                    },
                    {
                        title: '少数民族歌谣05',
                        type: ['上海市']
                    },
                    {
                        title: '少数民族歌谣06',
                        type: ['内蒙古自治区', '台湾省']
                    },
                    {
                        title: '少数民族歌谣07',
                        type: ['贵州省']
                    },

                ]
            }

        },
        created() {
            this.init()
        },
        watch: {

        },
        methods: {
            init() {
                // 第一步新建一个场景
                this.scene = new THREE.Scene()
                THREE.Cache.enabled = true;


                this.setCamera()
                this.setRenderer()
                this.setController()
                this.setRaycaster()
                this.loadMapData()
            },

            // 搜索高亮地区
            showRegion(provinceName){
                try {
                    if (this.obj3d !== null) {
                        for (let typeElement of this.lastSearch) {
                            this.obj3d = this.map.children.filter((item) => item.properties.name === typeElement)
                            this.obj3d[0].children[0].material[0].color.set('#3D479C')
                            this.obj3d[0].children[0].material[1].color.set('#3D479C')
                        }
                        this.lastSearch = ''
                    }
                    // 记录上一次搜索的省份
                    this.lastSearch = provinceName
                    this.obj3d = null
                    for (let typeElement of provinceName) {
                        this.obj3d = this.map.children.filter((item) => item.properties.name === typeElement)
                        this.obj3d[0].children[0].material[0].color.set('#2EA6B4')
                        this.obj3d[0].children[0].material[1].color.set('#2EA6B4')
                    }
                } catch (e) {
                    console.log(e)
                }

            },

            // 新建透视相机
            setCamera() {
                // 第二参数就是 长度和宽度比 默认采用浏览器  返回以像素为单位的窗口的内部宽度和高度
                this.camera = new THREE.PerspectiveCamera(10000, window.innerWidth / window.innerHeight, 0.1, 100000);
                this.camera.position.set( 25, 10, 120 );
                this.camera.lookAt( 0, 0, 0 );
            },

            // 设置渲染器
            setRenderer() {
                this.renderer = new THREE.WebGLRenderer()
                // 设置画布的大小
                this.renderer.setSize(window.innerWidth, window.innerHeight)
                //这里其实就是canvas 画布  renderer.domElement
                document.body.appendChild(this.renderer.domElement)
            },

            // render 方法
            render() {
                this.renderer.render(this.scene, this.camera)
            },

            setRaycaster() {
                this.raycaster = new THREE.Raycaster()
                this.mouse = new THREE.Vector2()
                const onMouseMove = (event) => {
                    // 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
                    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1
                    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1

                    this.$refs.label.style.left = event.clientX + 2 + 'px';
                    this.$refs.label.style.top = event.clientY + 2 + 'px';
                }
                window.addEventListener('mousemove', onMouseMove, false)
            },
            setLight() {
                this.ambientLight = new THREE.AmbientLight('#ff0000')
                this.scene.add(this.ambientLight)
            },
            setController() {
                this.controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
                this.controls.update();
            },

            // 动画
            animate() {
                requestAnimationFrame(this.animate.bind(this))
                // 通过摄像机和鼠标位置更新射线
                this.raycaster.setFromCamera(this.mouse, this.camera)
                // 算出射线与当前场景相交的对象有那些
                const intersects = this.raycaster.intersectObjects(
                    this.scene.children,
                    true
                )

                // 恢复上一次清空的
                if (this.lastPick) {
                    this.lastPick.object.material[0].color.set('#3D479C')
                    this.lastPick.object.material[1].color.set('#3D479C')
                }
                this.lastPick = null
                this.lastPick = intersects.find(
                    (item) => item.object.material && item.object.material.length === 2
                )
                // console.log(intersects)
                // this.scene.children[0].forEach((ele) => {
                //     if (ele.properties.name === this.inputVal) {
                //         this.scene.children[0].object.material[0].color.set('#2EA6B4')
                //         this.scene.children[0].object.material[1].color.set('#2EA6B4')
                //     }
                // })

                if (this.lastPick) {
                    this.lastPick.object.material[0].color.set('#2EA6B4')
                    this.lastPick.object.material[1].color.set('#2EA6B4')

                    // 显示 label
                    const properties = this.lastPick.object.parent.properties
                    this.$refs.label.textContent = properties.name
                    this.$refs.label.style.visibility = 'visible'
                } else {
                    this.$refs.label.style.visibility = 'hidden'
                }
                this.controls.update()
                this.render()
            },

            // 添加辅助系统
            addHelper() {
                const helper = new THREE.CameraHelper(this.camera)
                this.scene.add(helper)
            },



            // China Map JSON
            loadMapData() {
                const loader = new THREE.FileLoader()

                // 设置 output 格式
                loader.setResponseType('json')

                loader.load('../static/beijing.json', (data) => {

                    const jsondata = JSON.parse(JSON.stringify(data))
                    this.generateGeometry(jsondata)

                    this.animate()
                })
            },

            generateGeometry(jsondata) {
                // 初始化一个地图对象
                this.map = new THREE.Object3D()
                // 墨卡托投影转换
                const projection = d3.geoMercator().center([116.5, 40]).scale(5000).translate([0, 0])
                jsondata.features.forEach((elem) => {
                    // 定一个省份3D对象
                    const province = new THREE.Object3D()
                    // 每个的 坐标 数组
                    const coordinates = elem.geometry.coordinates
                    // 循环坐标数组
                    coordinates.forEach((multiPolygon) => {
                        multiPolygon.forEach((polygon) => {
                            const shape = new THREE.Shape()
                            const lineMaterial = new THREE.LineBasicMaterial({ color: '#4E64FF', linewidth: 2,})
                            const points = []
                            for (let i = 0; i < polygon.length; i++) {
                                let [x, y] = projection(polygon[i])
                                points.push(new THREE.Vector3(-x, y, 6));
                                if (i === 0) {
                                    shape.moveTo(-x, y)
                                }
                                shape.lineTo(-x, y)
                            }
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points)

                            const extrudeSettings = {
                                depth: 6,
                                bevelEnabled: false,
                            }

                            const geometry = new THREE.ExtrudeGeometry(
                                shape,
                                extrudeSettings
                            )
                            // 平面的 style
                            const material = new THREE.MeshBasicMaterial({
                                color: '#3D479C',
                                transparent: true,
                                opacity: 0.9,
                            })
                            // 3D 斜面的 style
                            const material1 = new THREE.MeshBasicMaterial({
                                color: '#3D479C',
                                transparent: true,
                                opacity: 0.8,
                            })
                            const mesh = new THREE.Mesh(geometry, [material, material1])
                            const line = new THREE.Line(lineGeometry, lineMaterial)

                            province.add(mesh)
                            province.add(line)
                        })
                    })
                    // 将 geojson 的 properties 放到模型中，后面会用到
                    province.properties = elem.properties
                    if (elem.properties.centroid) {
                        const [x, y] = projection(elem.properties.centroid)
                        province.properties._centroid = [x, y]
                    }
                    this.map.add(province)
                })
                function createDataPoint1(latitude, longitude, value) {
                    const vertexShader = `
    varying vec3 vColor;

    void main() {
      vColor = vec3(1.0, 1.0, 0.0);
      gl_PointSize = ${parseFloat(value)/20};
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

                    const fragmentShader = `
    varying vec3 vColor;

    void main() {
      float radius = 0.5;
      vec2 uv = gl_PointCoord - vec2(0.5);
      if (length(uv) > radius) discard;
      gl_FragColor = vec4(vColor, 1.0);
    }
  `;

                    const material = new THREE.ShaderMaterial({
                        uniforms: {},
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader
                    });

                    const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0)]);

                    const dataPoint = new THREE.Points(geometry, material);

                    // Convert latitude and longitude to Mercator projection
                    let [x, y] = projection([longitude,latitude])

                    dataPoint.position.set(-x, y, 7);

                    return dataPoint;
                }

                function createDataPoint(latitude, longitude, value) {
                    // var sphereGeo = new THREE.SphereGeometry(value, value, value);//创建球体
                    // var sphereMat = new THREE.MeshLambertMaterial({//创建材料
                    //     color:0x0000FF,
                    //     wireframe:false
                    // });
                    // var sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);//创建球体网格模型
                    // let [x, y] = projection([longitude,latitude])
                    // sphereMesh.position.set(0, 0, 6);//设置球的坐标
                    // return sphereMesh
                    const geometry = new THREE.CircleBufferGeometry(value, 32);
                    var material = new THREE.PointsMaterial({ color:"yellow", size: value/20 });
                    let [x, y] = projection([longitude,latitude])
                    const positions = new Float32Array([-x, y, 6]);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    return new THREE.Points(geometry, material);
                }
                d3.csv('../static/2018.csv').then(function(csvdata){
                    console.log(csvdata)
                    for(let i=0;i<csvdata.length;i++){
                        const dataPoint = createDataPoint1(csvdata[i].Lat, csvdata[i].Lng, csvdata[i].square);
                        this.scene.add(dataPoint)
                    }
                }.bind(this))

                this.scene.add(this.map)
                this.addHelper()

            }
        }
    })

</script>
</body>
</html>
